LPARAMETERS tuParam

****************************************************************
****************************************************************
* Standard prefix for all tools for Thor, allowing this tool to
*   tell Thor about itself.

IF PCOUNT() = 1 ;
		AND 'O' = VARTYPE( m.tuParam ) ;
		AND 'thorinfo' = LOWER( m.tuParam.Class )

	WITH tuParam

		* Required
		.Prompt		   = 'Populate DBF from DB2' && used when tool appears in a menu
		.Summary       = 'Populate a DBF from a FoxBin2Prg text file'
		.StatusBarText = .Summary	&& Normally the summary is fine for this

		* Optional
TEXT TO .Description NOSHOW && a description for the tool
This tool provides conversion from text to binary for ANY .DBF that was converted to text with FoxBin2Prg, including text files created with a DBF_Conversion_Support setting of 4.  For text files containing record data, the table will be repopulated with the data from the text file.
This tool will attempt to generate a .DBF file even if the text file is in a folder where the DBF_Conversion_Support setting is not 2.

Please note that this tool currently cannot restore the data in a table which contains Varbinary, Blob, or auto-increment (Integer) fields.
Also note that this tool was only intended to be used for free tables, though it might work for contained tables if you copy the database container to your temp folder.

This tool requires FoxBin2Prg 1.19.42 or later.
ENDTEXT

		.CanRunAtStartUp = .F.	&& Most of our tools probably won't do anything at startup

		* These are used to group and sort tools when they are displayed in menus or the Thor form
		.Source		   = 'MJP' && where did this tool come from?  Your own initials, for instance
		.Category      = 'Applications|FoxBin2Prg' && allows categorization for tools with the same source
		.Sort		   = 0 && the sort order for all items from the same Source, Category and Sub-Category

		* For public tools, such as PEM Editor, etc.
		.Version	   = '2015.10.09' && e.g., 'Version 7, May 18, 2011'
		.Author        = 'Mike Potjer'
		.Link          = 'https://bitbucket.org/mikepotjer/vfp-git-utils' && link to a page for this tool
		.VideoLink     = '' && link to a video for this tool

		.PlugInClasses = ''	&& Comma-separated list of classes that define plug-ins
		.PlugIns	   = ''	&& Comma-separated list of plug-in names as they will appear in the Manage Plug-Ins form

		.OptionClasses = ''	&& Comma-separated list of classes that define option settings
		.OptionTool    = ''	&& The tool name displayed on Thor's options page for the defined options

	ENDWITH

	RETURN m.tuParam
ENDIF

*-- The parameter can contain the name of the file to convert, so pass
*-- it to the tool code.
RETURN ToolCode( m.tuParam )


****************************************************************
****************************************************************
* Normal processing for this tool begins here.
PROCEDURE ToolCode
LPARAMETERS tuParam

LOCAL loConverter AS ConvertFoxBin2PrgTextToTable OF Thor_Tool_OSI_DB2toDBF.PRG, ;
	loMessage AS Exception, ;
	llSuccess

loConverter = CREATEOBJECT( "ConvertFoxBin2PrgTextToTable" )

llSuccess = m.loConverter.DoConvert( @m.loMessage, m.tuParam )

*-- We generate a success message, as well as error messages, so display
*-- whatever was returned.
loConverter.ShowMessage( m.loMessage )

*-- Provide a return value that can be used if you call this process
*-- from some other code.
RETURN EXECSCRIPT( _Screen.cThorDispatcher, "Result=", m.llSuccess )
ENDPROC

*********************************************************************
DEFINE CLASS ConvertFoxBin2PrgTextToTable AS Custom
*********************************************************************

#DEFINE cCRLF	CHR(13) + CHR(10)

*-- This stores a reference to the FoxBin2Prg object, so that we only
*-- need to load it once during the life of this class.
ioFoxBin2Prg = .NULL.
PROTECTED ioFoxBin2Prg

*-- This stores the name of the text file being processed, so that it
*-- is accessible to all methods.
icTextFileName = ""
PROTECTED icTextFileName

*-- This stores the XML from the text file which generates the table
*-- structure.
icTableStructureXML = ""
PROTECTED icTableStructureXML

*-- This stores the XML for the data records in the table.  The XML is
*-- formatted for use with the XMLTOCURSOR() function.
icXMLData = ""
PROTECTED icXMLData

*-- This property is used to store an Exception object for any errors
*-- generated by the DBF conversion hook, since we don't have way to
*-- directly return error information from the hook.
ioErrorInfo = .NULL.
PROTECTED ioErrorInfo

*********************************************************************
FUNCTION DoConvert

*!*	This is the main method for converting a FoxBin2Prg text file to a .DBF, and populating the
*!*	table with the data in the RECORDS node of the text file.

*!*	PARAMETERS:
*!*				toMessage (O) -	A variable passed by reference, which will be used to return result
*!*								messages to the calling code.
*!*		   tcTextFileName (O) -	The full path and file name of a FoxBin2Prg text file to process.
*!*								If omitted or invalid, you will be prompted for a file name.

*!*	RETURNS: Logical
*!*		.T. if the text file was successfully converted to binary and populated, .F. otherwise.
*********************************************************************
LPARAMETERS toMessage AS Exception, tcTextFileName AS String

PRIVATE poThorToolDB2ToDBF

LOCAL loFoxBin2Prg AS C_FoxBin2Prg OF "C:\Work\VFP\Shared\Tools\Thor\Tools\Components\FoxBin2Prg\FoxBin2Prg.PRG", ;
	lcTempTextFile, ;
	lcTempConfigFile, ;
	lcSetSafety, ;
	llSuccess

*-- Make sure we have a text file to process.
This.icTextFileName = This.GetTextFileName( @m.toMessage, m.tcTextFileName )
IF EMPTY( This.icTextFileName )
	RETURN .F.
ENDIF

*-- Get a reference to the FoxBin2Prg class, so we can use its API here.
loFoxBin2Prg = This.GetFoxBin2Prg( @m.toMessage )
IF ISNULL( m.loFoxBin2Prg )
	RETURN .F.
ENDIF

*-- Check the text file for record data.
IF NOT This.ProcessTextFile( @m.toMessage )
	RETURN .F.
ENDIF

IF EMPTY( This.icXMLData ) ;
		AND m.loFoxBin2Prg.hasSupport_Prg2Bin( This.icTextFileName )
	*-- There is no record data to restore, and the folder containing
	*-- the text file supports 2-way conversion of table files, so use
	*-- the native behavior to regenerate the table file in place.
	loFoxBin2Prg.evaluateConfiguration( "", "", "", "", "", "", "", "", This.icTextFileName, "D" )

	llSuccess = ( m.loFoxBin2Prg.Execute( This.icTextFileName, "", "", .F., "1", "0", "1", .NULL., ;
			@m.toMessage ) = 0 )
ELSE
	*-- The table has record data to restore, or FoxBin2Prg is not
	*-- configured for 2-way conversion in the folder where the text
	*-- is located.  The table will be generated in the user's temp
	*-- folder, and if successful, copied back to the folder where the
	*-- text file is located.
	*-- Create a text file in the temp folder containing just the table
	*-- structure information.  FoxBin2Prg fails if you try to create
	*-- a table from a text file containing record data.
	lcTempTextFile = FORCEPATH( This.icTextFileName, GETENV("TEMP") )
	STRTOFILE( This.icTableStructureXML, m.lcTempTextFile )

	*-- Create a FoxBin2Prg config file in the temp folder to ensure
	*-- that the table can be created.  Backups will be turned off so
	*-- that we don't generate any unnecessary files, and the DBF support
	*-- will be set to 2-way so the binaries can be created.
	lcTempConfigFile = ADDBS( GETENV("TEMP") ) + "FoxBin2Prg.CFG"
	STRTOFILE( "ExtraBackupLevels: 0" + cCRLF + "DBF_Conversion_Support: 2" + cCRLF, m.lcTempConfigFile )

	*-- Apply the configuration settings for the temp folder.
	loFoxBin2Prg.evaluateConfiguration( "", "", "", "", "", "", "", "", JUSTPATH( m.lcTempTextFile ), "D" )

	*-- Specify a procedure in this .PRG as the hook procedure for the
	*-- DBF creation process.  Make sure the error property is cleared
	*-- so we can check for errors that occurred in the hook procedure.
	loFoxBin2Prg.run_AfterCreateTable = "DB2ToDBF_AfterCreateTable"
	This.ioErrorInfo = .NULL.

	*-- Store a reference to this class in a private variable so that
	*-- the hook procedure can call methods of this class.
	poThorToolDB2ToDBF = This

	*-- Attempt to generate the table in the temp folder.
	llSuccess = ( m.loFoxBin2Prg.Execute( m.lcTempTextFile, "", "", .F., "1", "0", "1", .NULL., ;
			@m.toMessage ) = 0 )

	*-- Release the private variable, and clear the conversion hook
	*-- setting to prevent it from accidentally being called when it
	*-- doesn't apply.
	RELEASE poThorToolDB2ToDBF
	loFoxBin2Prg.run_AfterCreateTable = SPACE(0)

	*-- Check for errors from the conversion hook.
	IF m.llSuccess ;
			AND NOT ISNULL( This.ioErrorInfo )
		llSuccess = .F.
		toMessage = This.ioErrorInfo
	ENDIF

	*-- Delete the temporary text and config files.
	ERASE ( m.lcTempTextFile )
	ERASE ( m.lcTempConfigFile )

	IF m.llSuccess
		*-- Processing was successful, so copy the table files back to
		*-- the folder where the text file is located.
		*-- Turn off the safety setting so we can overwrite an existing
		*-- table file without bothering the developer.
		lcSetSafety = SET("Safety")
		SET SAFETY OFF

		COPY FILE ( FORCEEXT( m.lcTempTextFile, "DBF" ) ) TO ( FORCEEXT( This.icTextFileName, "DBF" ) )

		*-- The table might not have memos or indexes, so check for
		*-- those files before copying.
		IF FILE( FORCEEXT( m.lcTempTextFile, "FPT" ) )
			COPY FILE ( FORCEEXT( m.lcTempTextFile, "FPT" ) ) TO ( FORCEEXT( This.icTextFileName, "FPT" ) )
		ENDIF

		IF FILE( FORCEEXT( m.lcTempTextFile, "CDX" ) )
			COPY FILE ( FORCEEXT( m.lcTempTextFile, "CDX" ) ) TO ( FORCEEXT( This.icTextFileName, "CDX" ) )
		ENDIF

		SET SAFETY &lcSetSafety.
	ENDIF

	*-- Cleanup the table files that were created in the temp folder.
	ERASE ( FORCEEXT( m.lcTempTextFile, "DBF" ) )
	ERASE ( FORCEEXT( m.lcTempTextFile, "FPT" ) )
	ERASE ( FORCEEXT( m.lcTempTextFile, "CDX" ) )
ENDIF

IF m.llSuccess ;
		AND FILE( FORCEEXT( This.icTextFileName, "DBF" ) )
	*-- Processing was successful, so generate a success message.
	toMessage = CREATEOBJECT( "Exception" )
	toMessage.Message = "Table '" + FORCEEXT( This.icTextFileName, "DBF" ) + "' was successfully created."
ENDIF

RETURN m.llSuccess
ENDFUNC

*********************************************************************
PROCEDURE AfterCreateTable

*!*	This method is to be called from the DBF conversion hook in order to populate the table that
*!*	was created with the data that was stored in the text file.

*!*	PARAMETERS:
*!*		These are the same parameters passed to the DBF conversion hook from FoxBin2Prg.
*!*		  tnDataSessionID (R) -	The data session in which the table was created and where it should
*!*								currently be open.
*!*			 tcOutputFile (R) -	The full path and file name of the .DBF file that was generated.
*!*				  toTable (O) -	A custom table information object used by FoxBin2Prg.  This parameter
*!*								is currently not used in this method, and could be omitted.

*!*	RETURNS: None
*********************************************************************
LPARAMETERS tnDataSessionID AS Integer, tcOutputFile AS String, toTable AS Object

LOCAL loErrorInfo AS Exception, ;
	lnDataSessionID, ;
	lnAliasCount, ;
	laAliases[1], ;
	lcAlias, ;
	lnFieldCount, ;
	laFields[1], ;
	lnMemoCount, ;
	laMemoFields[1], ;
	lcSearchExpr, ;
	lcReplaceExpr, ;
	lcBeginDelimiter, ;
	lcEndDelimiter, ;
	lcResult, ;
	llPackMemos, ;
	xx

*-- If the text file didn't contain any record data, there's nothing
*-- to do here.
IF EMPTY( This.icXMLData )
	RETURN
ENDIF

lnDataSessionID = SET("Datasession" )

TRY
	*-- Make sure we're in the same data session as the table that was
	*-- created.
	IF NOT m.lnDataSessionID = m.tnDataSessionID
		SET DATASESSION TO ( m.tnDataSessionID )
	ENDIF

	*-- Look for an alias that was used to open the table.
	lnAliasCount = AUSED( laAliases, m.tnDataSessionID, m.tcOutputFile )

	*-- If no aliases were found, abort, otherwise just use the first
	*-- alias that was found.
	IF m.lnAliasCount = 0
		ERROR "Table '" + m.tcOutputFile + "' is not open, and could not be populated"
	ELSE
		lcAlias = laAliases[1,1]
	ENDIF

	*-- There is some special processing we may need to do, depending
	*-- on the types of fields in the table, so get that information.
	lnFieldCount = AFIELDS( laFields, m.lcAlias )

	lnMemoCount = 0

	FOR xx = 1 TO m.lnFieldCount
		DO CASE
			CASE INLIST( laFields[m.xx,2], "Q", "W" ) ;
					OR ( laFields[m.xx,2] = "I" ;
						AND laFields[m.xx,18] > 0 )
				*-- While FoxBin2Prg can export Varbinary and Blob data
				*-- and auto-increment field values, I haven't found a
				*-- way to restore any of these properly, so abort if
				*-- any of these data types are present.
				ERROR "This tool does not support tables containing Varbinary, Blob, or auto-increment fields."

			CASE laFields[m.xx,2] = "L"
				*-- FoxBin2Prg stores logical field values in the text
				*-- file as .T. or .F., but XMLTOCURSOR() only recognizes
				*-- true or false for those values, so convert all the
				*-- values for this field.
				lcSearchExpr = "<" + laFields[m.xx,1] + ">.F.</" + laFields[m.xx,1] + ">"
				lcReplaceExpr = "<" + laFields[m.xx,1] + ">false</" + laFields[m.xx,1] + ">"
				This.icXMLData = STRTRAN( This.icXMLData, m.lcSearchExpr, m.lcReplaceExpr, 1, -1, 1 )

				*-- Rather than rebuild the expressions, just replace
				*-- the values and reuse them.
				lcSearchExpr = STRTRAN( m.lcSearchExpr, ">.F.<", ">.T.<", 1, 1, 1 )
				lcReplaceExpr = STRTRAN( m.lcReplaceExpr, ">false<", ">true<", 1, 1, 1 )
				This.icXMLData = STRTRAN( This.icXMLData, m.lcSearchExpr, m.lcReplaceExpr, 1, -1, 1 )

			CASE laFields[m.xx,2] = "M" ;
					AND laFields[m.xx,6] = .F.
				*-- For whatever reason, XMLTOCURSOR() restores memo
				*-- fields using only a linefeed as the end of line
				*-- character.  We need to fix that, so get a list of
				*-- all the memo fields in the table.  Ignore binary
				*-- memo fields, since they could be storing something
				*-- other than text.
				lnMemoCount = m.lnMemoCount + 1
				DIMENSION laMemoFields[m.lnMemoCount]
				laMemoFields[m.lnMemoCount] = laFields[m.xx,1]

			*!* MJP -- Removed 09/23/2015 11:56:28
			*-- An auto-increment field is read-only, so my first thought
			*-- was to simply remove that field from the XML.  However,
			*-- XMLTOCURSOR() does not trigger the auto-increment behavior,
			*-- so you simply end up with a cursor where the auto-increment
			*-- field is zero for every record.
			*-- If we really needed to support this, we would have to
			*-- ALTER TABLE to change the field to a normal integer,
			*-- populate the table, then ALTER TABLE again to restore
			*-- the auto-increment settings.
			*!* CASE laFields[m.xx,2] = "I" ;
			*!* 		AND laFields[m.xx,18] > 0
			*!* 	lcBeginDelimiter = "<" + laFields[m.xx,1] + ">"
			*!* 	lcEndDelimiter = "</" + laFields[m.xx,1] + ">"

			*!* 	lcResult = STREXTRACT( This.icXMLData, m.lcBeginDelimiter, m.lcEndDelimiter, 1, 1+4 )
			*!* 	DO WHILE NOT EMPTY( m.lcResult )
			*!* 		This.icXMLData = STRTRAN( This.icXMLData, m.lcResult, SPACE(0), 1, 1, 1 )
			*!* 		lcResult = STREXTRACT( This.icXMLData, m.lcBeginDelimiter, m.lcEndDelimiter, 1, 1+4 )
			*!* 	ENDDO

			OTHERWISE
				*-- All other data types can be imported as-is.
		ENDCASE
	ENDFOR

	*-- Import the data into the cursor.  I found that the 4096 flag
	*-- was required to import a memo (binary) value properly.
	XMLTOCURSOR( This.icXMLData, m.lcAlias, 4096+8192 )

	IF m.lnMemoCount > 0
		*-- XMLTOCURSOR() only uses linefeeds as the end-of-line character
		*-- when writing memo fields, so we want to convert them back
		*-- to CR+LF.
		llPackMemos = .F.

		SELECT ( m.lcAlias )
		GO TOP
		SCAN
			FOR xx = 1 TO m.lnMemoCount
				lcResult = EVALUATE( m.lcAlias + "." + laMemoFields[m.xx] )
				IF OCCURS( CHR(10), m.lcResult ) > 0
					*-- The current memo field contains linefeeds, so
					*-- convert them to carriage return + linefeed.
					lcResult = STRTRAN( m.lcResult, CHR(10), cCRLF )
					REPLACE ( laMemoFields[m.xx] ) WITH m.lcResult ;
							IN ( m.lcAlias )

					*-- Pack the memo file when we're done.
					llPackMemos = .T.
				ENDIF
			ENDFOR
		ENDSCAN

		*-- If any memo fields were updated, the memo file will contain
		*-- some bloat that we can remove, so attempt to pack the memo
		*-- file.  Since the table was just created, it is opened for
		*-- exclusive access by default, so we should be able to PACK.
		IF m.llPackMemos
			PACK MEMO
		ENDIF
	ENDIF

CATCH TO loErrorInfo
	*-- Store the error object so it can accessed when we return to
	*-- this class from the FoxBin2Prg process.
	This.ioErrorInfo = m.loErrorInfo

FINALLY
	*-- Make sure the data session is restored if we changed it.
	IF NOT m.lnDataSessionID = SET("Datasession")
		SET DATASESSION TO ( m.lnDataSessionID )
	ENDIF
ENDTRY

RETURN
ENDPROC

*********************************************************************
PROCEDURE Destroy
*********************************************************************
*-- Cleanup the objects stored by this class.
This.ioFoxBin2Prg = .NULL.
This.ioErrorInfo = .NULL.

RETURN
ENDPROC

*********************************************************************
PROTECTED FUNCTION GetTextFileName

*!*	This method ensures that we have a valid text file to process.

*!*	PARAMETERS:
*!*			  toErrorInfo (O) -	A variable passed by reference which can be populated with an
*!*								Exception object containing information about any errors which
*!*								occur in this method.
*!*		   tcTextFileName (O) -	The name of the text file to process.  If omitted or invalid, you
*!*								will be prompted for a text file to process.

*!*	RETURNS: Character
*!*		Returns the name of the text file to process, if successful, otherwise returns an empty
*!*		string if the file was not valid or you didn't select anything.
*********************************************************************
LPARAMETERS toErrorInfo AS Exception, tcTextFileName AS String

LOCAL loFoxBin2Prg AS C_FoxBin2Prg OF "C:\Work\VFP\Shared\Tools\Thor\Tools\Components\FoxBin2Prg\FoxBin2Prg.PRG", ;
	lcTextFileName, ;
	lcTextExtension

lcTextFileName = SPACE(0)

*-- Get a reference to FoxBin2Prg, which we'll use to make sure a valid
*-- file type was selected.
loFoxBin2Prg = This.GetFoxBin2Prg( @m.toErrorInfo )
IF ISNULL( m.loFoxBin2Prg )
	RETURN m.lcTextFileName
ENDIF

TRY
	IF VARTYPE( m.tcTextFileName ) = "C" ;
			AND NOT EMPTY( m.tcTextFileName ) ;
			AND FILE( m.tcTextFileName )
		*-- The name of an existing file was specified, so use it.
		lcTextFileName = m.tcTextFileName
	ELSE
		*-- Check what extension FoxBin2Prg is expecting for a table
		*-- text file.
		lcTextExtension = m.loFoxBin2Prg.get_Ext2FromExt( "DBF" )

		*-- Prompt the user to select a text file, filtering the list
		*-- to show just the extension FoxBin2Prg expects.
		lcTextFileName = GETFILE( "FoxBin2Prg Text (" + m.lcTextExtension + "):" + m.lcTextExtension, ;
				"", "Convert", 0, "Select text file to convert to DBF" )

		*-- Abort if no file was selected.
		IF EMPTY( m.lcTextFileName )
			ERROR "No text file selected for conversion"
		ENDIF
	ENDIF

	*-- Attempt to load the settings for the [D]irectory containing the
	*-- text file, but don't override any config file settings.
	loFoxBin2Prg.evaluateConfiguration( "", "", "", "", "", "", "", "", JUSTPATH( m.lcTextFileName ), "D" )

	*-- Check if the selected file has a valid text extension based on
	*-- the FoxBin2Prg configuration that applies to that folder.  Abort
	*-- if the file is not valid.
	lcTextExtension = m.loFoxBin2Prg.get_Ext2FromExt( "DBF" )
	IF NOT UPPER( m.lcTextExtension ) == UPPER( JUSTEXT( m.lcTextFileName ) )
		ERROR "FoxBin2Prg does not support text to DBF for file '" + m.lcTextFileName + "'"
	ENDIF

CATCH TO toErrorInfo
	lcTextFileName = SPACE(0)
ENDTRY

RETURN m.lcTextFileName
ENDFUNC

*********************************************************************
PROTECTED FUNCTION GetFoxBin2Prg

*!*	This method attempts to find FoxBin2Prg and load the API object.

*!*	PARAMETERS:
*!*		toErrorInfo (O) -	A variable passed by reference which can be populated with an Exception
*!*							object containing information about any errors which occur in this method.

*!*	RETURNS: Object
*!*		If successful, returns a reference to the FoxBin2Prg object, otherwise returns NULL.
*********************************************************************
LPARAMETERS toErrorInfo AS Exception

LOCAL loFoxBin2Prg AS C_FoxBin2Prg OF "C:\Work\VFP\Shared\Tools\Thor\Tools\Components\FoxBin2Prg\FoxBin2Prg.PRG", ;
	lcFoxBin2PrgPath

IF VARTYPE( This.ioFoxBin2Prg ) = "O"
	*-- FoxBin2Prg was already loaded early, so use the existing object
	*-- reference.
	loFoxBin2Prg = This.ioFoxBin2Prg
ELSE
	TRY
		*-- Retrieve the FoxBin2Prg folder.  The default function code
		*-- only returns an empty value if the folder was not found and
		*-- the user didn't select anything when prompted.
		lcFoxBin2PrgPath = EXECSCRIPT( _Screen.cThorDispatcher, "Thor_Proc_GetFoxBin2PrgFolder" )

		DO CASE
			CASE EMPTY( m.lcFoxBin2PrgPath )
				*-- The location of FoxBin2Prg could not be determined,
				*-- so generate an error and abort.
				ERROR "FoxBin2Prg folder could not be determined"

			CASE FILE( FORCEPATH( "FoxBin2Prg.EXE", m.lcFoxBin2PrgPath ) )
				*-- The app was found.

			OTHERWISE
				*-- The FoxBin2Prg path returned is invalid, so generate
				*-- an error and abort.
				ERROR "'" + m.lcFoxBin2PrgPath + "' is not a valid FoxBin2Prg folder"
		ENDCASE

		*-- Attempt to instantiate FoxBin2Prg.
		SET PROCEDURE TO ( ADDBS( m.lcFoxBin2PrgPath ) + "FOXBIN2PRG.EXE" ) ADDITIVE
		loFoxBin2Prg = CREATEOBJECT( "C_FoxBin2Prg" )

		*-- If FoxBin2Prg was successfully loaded, store a reference
		*-- for next time, otherwise abort with an error.
		IF VARTYPE( m.loFoxBin2Prg ) = "O"
			This.ioFoxBin2Prg = m.loFoxBin2Prg
		ELSE
			ERROR "Unable to instantiate FoxBin2Prg"
		ENDIF

	CATCH TO toErrorInfo
		loFoxBin2Prg = .NULL.
	ENDTRY
ENDIF

RETURN m.loFoxBin2Prg
ENDFUNC

*********************************************************************
PROTECTED FUNCTION ProcessTextFile

*!*	This method separates the table meta data from the record data.  The structural meta data is
*!*	formatted so that FoxBin2Prg can create the table, and the record data is formatted so that it
*!*	can be imported via XMLTOCURSOR().

*!*	PARAMETERS:
*!*		toErrorInfo (O) -	A variable passed by reference which can be populated with an Exception
*!*							object containing information about any errors which occur in this method.

*!*	RETURNS: Logical
*!*		.T. if successful, .F. if an error occurs.
*********************************************************************
LPARAMETERS toErrorInfo AS Exception

LOCAL llSuccess, ;
	lcTextFileContent, ;
	lnRecordsBegin, ;
	lnRecordsEnd

llSuccess = .T.
This.icTableStructureXML = SPACE(0)
This.icXMLData = SPACE(0)

TRY
	*-- Read the entire text file, and search for a RECORDS node, which
	*-- is where all the row data will be.
	lcTextFileContent = FILETOSTR( This.icTextFileName )
	lnRecordsBegin = ATC( "<RECORDS>", m.lcTextFileContent )
	lnRecordsEnd = 0

	IF m.lnRecordsBegin > 0
		*-- Make sure the end tag exists, in case the begin tag was in
		*-- a description or something.
		lnRecordsEnd = RAT( "</RECORDS>", UPPER( m.lcTextFileContent ) )
		IF m.lnRecordsEnd = 0
			lnRecordsBegin = 0
		ENDIF
	ENDIF

	IF m.lnRecordsBegin = 0
		*-- There is no data node, so we should be able to use the
		*-- entire text file as-is to create the table.
		This.icTableStructureXML = m.lcTextFileContent
	ELSE
		*-- Extract all the structural meta data preceding the data
		*-- node, and close it off with the end tag so that FoxBin2Prg
		*-- can use it create the table structure.
		This.icTableStructureXML = LEFT( m.lcTextFileContent, m.lnRecordsBegin - 1 ) + cCRLF + "</TABLE>" + cCRLF

		*-- The XML FoxBin2Prg generates for the data is pretty much
		*-- the same format expected by XMLTOCURSOR().  We just need
		*-- to replace the RECORDS tags with the VFPData tags, and add
		*-- the XML header.
		This.icXMLData = [<?xml version="1.0"?>] + cCRLF ;
				+ "<VFPData>" + cCRLF ;
				+ SUBSTR( m.lcTextFileContent, m.lnRecordsBegin + 9, m.lnRecordsEnd - m.lnRecordsBegin - 9 ) ;
				+ "</VFPData>"
	ENDIF

CATCH TO toErrorInfo
	llSuccess = .F.
ENDTRY

RETURN m.llSuccess
ENDFUNC

*********************************************************************
PROCEDURE ShowMessage

*!*	This method displays the contents (if any) of the message object.

*!*	PARAMETERS:
*!*		toMessage (O) -	An Exception object containing either error information or just a message
*!*						of some sort.  If omitted or not an Exception object, this method will just
*!*						ignore it and do nothing.

*!*	RETURNS: None
*********************************************************************
LPARAMETERS toMessage AS Exception

DO CASE
	CASE NOT TYPE( "m.toMessage.BaseClass" ) = "C" ;
			OR NOT UPPER( m.toMessage.BaseClass ) == UPPER( "Exception" )
		*-- The message parameter was omitted or invalid, ignore it.

	CASE m.toMessage.ErrorNo = 0
		*-- The message does not include an error number, so assume it
		*-- is just an informational message and not an error.  Display
		*-- just the message, and allow the dialog to timeout.
		MESSAGEBOX( m.toMessage.Message, 64, "DBF Conversion", 3000 )

	OTHERWISE
		*-- The message is a normal Exception error.  Report the error
		*-- along with some of the additional info which can be used
		*-- for debugging.
		MESSAGEBOX( m.toMessage.Message + CHR(13) + "Error occurred in " + m.toMessage.Procedure ;
				+ ", Line " + TRANSFORM( m.toMessage.LineNo) ;
				+ IIF( EMPTY( m.toMessage.LineContents ) ;
					OR UPPER( LEFT( m.toMessage.LineContents, 6 ) ) == "ERROR ", ;
					SPACE(0), cCRLF + m.toMessage.LineContents ), 16, "DBF Conversion Error" )
ENDCASE

ENDPROC

*********************************************************************
FUNCTION GetMenuItemExec

*!*	This method checks if the specified file name is a text file that could be converted to .DBF,
*!*	and generates the command that would be added to the Finder context menu to call this tool to
*!*	convert that file to .DBF.

*!*	PARAMETERS:
*!*		tcFileName (R) -	The file name and extension, preferrably including a path, of a file
*!*							that might be a FoxBin2Prg text file for a .DBF file.  This is expected
*!*							to be the file name that Finder passes to Thor_Proc_FinderContextMenu.PRG.

*!*	RETURNS: Character
*!*		If the file name is a FoxBin2Prg text file for a .DBF file, the command to execute the
*!*		DB2-to-DBF tool is returned, suitable for adding to the Finder context menu.  Otherwise
*!*		returns an empty string.
*********************************************************************
LPARAMETERS tcFileName AS String

LOCAL loFoxBin2Prg AS C_FoxBin2Prg OF "C:\Work\VFP\Shared\Tools\Thor\Tools\Components\FoxBin2Prg\FoxBin2Prg.PRG", ;
	lcFolder, ;
	lcTextExtension, ;
	lcExec

lcExec = SPACE(0)

TRY
	*-- Attempt to get a reference to FoxBin2Prg.  If we can't get it,
	*-- abort, because we can't check if the file name has the required
	*-- text file extension.
	loFoxBin2Prg = This.GetFoxBin2Prg()
	IF ISNULL( m.loFoxBin2Prg )
		EXIT
	ENDIF

	*-- If a folder was included, attempt to load the configuration
	*-- settings that apply to that folder.
	lcFolder = JUSTPATH( m.tcFileName )
	IF NOT EMPTY( m.lcFolder ) ;
			AND DIRECTORY( m.lcFolder )
		loFoxBin2Prg.evaluateConfiguration( "", "", "", "", "", "", "", "", m.lcFolder, "D" )
	ENDIF

	*-- Get the text extension for .DBF files.
	lcTextExtension = m.loFoxBin2Prg.get_Ext2FromExt( "DBF" )

	*-- If the extension is a valid text file extension, generate the
	*-- command to pass the text file name to this tool to create and
	*-- populate a .DBF from the text file.
	IF NOT EMPTY( m.lcTextExtension ) ;
			AND UPPER( JUSTEXT( m.tcFileName ) ) == UPPER( m.lcTextExtension )
		TEXT TO m.lcExec TEXTMERGE NOSHOW PRETEXT 1+2
			EXECSCRIPT( _SCREEN.cThorDispatcher, "Thor_Tool_FoxBin2Prg_DB2toDBF", [<<m.tcFileName>>] )
		ENDTEXT
	ENDIF

CATCH
	*-- Return an empty string if any errors occur.
	lcExec = SPACE(0)
ENDTRY

RETURN m.lcExec
ENDPROC

ENDDEFINE


*********************************************************************
PROCEDURE DB2ToDBF_AfterCreateTable

*!*	This procedure is the DBF conversion hook used to connect the conversion class to the FoxBin2Prg
*!*	process that creates the table file.

*!*	PARAMETERS:
*!*		These are the parameters that FoxBin2Prg passes to the hook procedure.

*!*	RETURNS: None
*!*		FoxBin2Prg doesn't retrieve the return value from hook procedures.
*********************************************************************
LPARAMETERS tnDataSessionID AS Integer, tcOutputFile AS String, toTable AS Object

*-- We expect a private variable containing a reference to the conversion
*-- class defined in this .PRG.  Call a method of the conversion class
*-- to perform the hook processing.
poThorToolDB2ToDBF.AfterCreateTable( m.tnDataSessionID, m.tcOutputFile, m.toTable )

RETURN
ENDPROC
